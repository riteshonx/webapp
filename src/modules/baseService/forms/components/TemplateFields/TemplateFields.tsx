import React, { ReactElement, useContext, useEffect, useState } from 'react'
import { Grid, TextField, Tooltip } from '@material-ui/core';
import FieldRenderer from '../FieldRenderer/FieldRenderer';
import {templateCreationContext, updateFieldContext} from '../../context/templateCreation/context';
import {setSelectedTemplateField, setDragFrom, setDropedTo, 
    setTemplateList, setFormCurrentTab, setCustomList, setDragedInput } from'../../context/templateCreation/action'; 
import { FormsRoles } from '../../../../../utils/role';
import { stateContext } from '../../../../root/context/authentication/authContext';
import { setEditMode, setIsLoading } from '../../../../root/context/authentication/action';
import { TemplateData } from '../../models/template';
import TemplateName from '../../components/TemplateName/TemplateName';  
import { LOAD_CONFIGURATION_LIST } from '../../grqphql/queries/customList';
import {client} from '../../../../../services/graphql';
import { FIXED_FIELDS, InputType } from '../../../../../utils/constants';
import { getUniqueName } from '../../../../../utils/helper';
import { constructTableData } from '../../utils/helper';
import { v4 as uuidv4 } from 'uuid';
import Notification,{ AlertTypes } from "../../../../shared/components/Toaster/Toaster";
import './TemplateFields.scss';
import { canViewTemplates } from '../../utils/permission';
import AutoGeneratedFields from '../AutoGeneratedFields/AutoGeneratedFields';
import { useDebounce } from "../../../../../customhooks/useDebounce";

interface Iprops{
    refreshFields?:()=>any
}

function TemplateFields(props:Iprops): ReactElement {
    const {createTemplateState, createTemplateDispatch }:any = useContext(templateCreationContext);
    const {dispatch, state }:any = useContext(stateContext);
    const [nonAutoGeneratedField, setNonAutoGeneratedField] = useState([]);
    const [newCaptionName, setNewCaptionName] = useState('');
    const debounceName = useDebounce(newCaptionName, 300);
    const [isSubject, setIsSubject] = useState(false);
    const [isRequired,setIsRequired] = useState(false);
    const [customErrMsg,setCustomErrMsg] = useState('');
    const [isDuplicate,setIsDuplicate] = useState(false);
  
    useEffect(() => {
      checkIfCaptionNameIsDuplicate();
    }, [debounceName]);

    useEffect(() => {
        if(canViewTemplates){
            fetchConfigListData();
        }
    }, [])

    useEffect(()=>{
        if(createTemplateState.templateList.length>0){
            const nonAutoGenerated= createTemplateState.templateList.filter((item:TemplateData)=> !item.autoGenerated)
            setNonAutoGeneratedField(nonAutoGenerated);
        } else{
            setNonAutoGeneratedField([]);
        }
    },[createTemplateState.templateList])

    const fetchConfigListData=async()=>{
        try{
            dispatch(setIsLoading(true));
            const customListingData= await client.query({
                query:LOAD_CONFIGURATION_LIST,
                variables:{},
                fetchPolicy: 'network-only',
                context:{role: FormsRoles.viewFormTemplate}
            })
            if(customListingData.data.configurationLists.length>0){
                createTemplateDispatch(setCustomList(JSON.parse(JSON.stringify(customListingData.data.configurationLists))));
            }
            dispatch(setIsLoading(false));
        }catch(error){
            dispatch(setIsLoading(false));
        }
    }

    const SelectItem=(argItem: TemplateData)=>{
        if(!isRequired){
            createTemplateDispatch(setFormCurrentTab('EXISTING'));
            createTemplateDispatch(setSelectedTemplateField(argItem));
        }else{
            return
        }
    }

    const selectItemEditable = (argItem: TemplateData)=>{
        if(!isRequired){
            const items = createTemplateState.templateList.map((item:TemplateData)=>
            item.id == argItem.id? {...item,isEditable:!item.isEditable}:{...item,isEditable:false})
            const itemName = createTemplateState.templateList.find((item:TemplateData)=>
            item.id == argItem.id? item.caption:"")
            setNewCaptionName(itemName.caption)
            createTemplateDispatch(setTemplateList(items));
        }else{
            return
        }
    }

    const handleUserDefinedChange = (e:any,argItem: TemplateData)=>{
        setNewCaptionName(e.target.value.trim())
        if(e.target.value.trim()){
            setIsRequired(false)
            const items = createTemplateState.templateList.map((item:TemplateData)=>
            item.id == argItem.id? {...item,caption:e.target.value.trim()}:{...item})
            createTemplateDispatch(setTemplateList(items));
        }else{
            setIsRequired(true)
            setCustomErrMsg("label name is required")
            const items = createTemplateState.templateList.map((item:TemplateData)=>
            item.id == argItem.id? {...item,caption:e.target.value.trim()}:{...item})
            createTemplateDispatch(setTemplateList(items));
        }
    }

    const checkIfCaptionNameIsDuplicate = () => {
        setCustomErrMsg("")
        if (createTemplateState.selectedTemplateField) {
          const items = [...createTemplateState.templateList];
          const selected = items.find(
            (item) => item.id === createTemplateState.selectedTemplateField.id
          );
          const index = items.indexOf(selected);
          const duplicates = items.filter(
            (item: any, itemIndex: number) =>
              item.caption.trim().toLocaleLowerCase() ===
                debounceName.trim().toLocaleLowerCase() && itemIndex !== index
          );
          if (duplicates.length !== 0) {
            createTemplateState.selectedTemplateField.duplicateCaption = true;
            setIsDuplicate(true)
            setCustomErrMsg("label name already exists")
          } else {
            createTemplateState.selectedTemplateField.duplicateCaption = false;
            setIsDuplicate(false)
          }
          setIsSubject(false);
          if (
            createTemplateState.selectedTemplateField.elementId !==
              FIXED_FIELDS.SUBJECT &&
            debounceName.trim().toLocaleLowerCase() === "subject"
          ) {
            setIsSubject(true);
            setCustomErrMsg("Cannot add field named Subject. Subject is reserved for the fixed field input type")
          }
          if (
            createTemplateState.templateList[index].duplicateCaption !==
            createTemplateState.selectedTemplateField.duplicateCaption
          ) {
            createTemplateDispatch(
              setSelectedTemplateField(createTemplateState.selectedTemplateField)
            );
          }
        }
      };

    const dragOver=(e: any)=>{
        const eve = e as Event;
        eve.stopPropagation();
        eve.preventDefault();
        const inputData=JSON.parse(e.currentTarget.dataset.index);
        if(Number(inputData.index) !== createTemplateState.dropedTo){
            createTemplateDispatch(setDropedTo(Number(inputData.index)));
        }
    }

    const dragLeave=(e: any)=>{
        const eve = e as Event;
        eve.stopPropagation();
        eve.preventDefault();
        if(-1 !== createTemplateState.dragedFrom){
            createTemplateDispatch(setDragFrom(-1));
        }
        if(-1 !== createTemplateState.dropedTo){
            createTemplateDispatch(setDropedTo(-1));
        }
    }

    const setFromIndex=(e: any )=>{
        e.dataTransfer.setData('text/html', e.target.id);
        const inputData=JSON.parse(e.currentTarget.dataset.index);
        if(Number(inputData.index) !== createTemplateState.dragedFrom){
            createTemplateDispatch(setDragFrom(Number(inputData.index)));
        }
    }

    const dragLeaveInput=(e:any)=>{
        const inputData=JSON.parse(e.currentTarget.dataset.index);
        if(Number(inputData.index) === createTemplateState.dropedTo){
            createTemplateDispatch(setDropedTo(Number(-1)));
        }
    }

    const renderInputFields=()=>{
        return createTemplateState.templateList.map((item: TemplateData, i:number) =>{
            if(!item.autoGenerated){
             return   <Grid item key={`${item.caption}-${i}`} id={`${item.caption}-${i}`}
                            draggable={"true"} sm={item.width} 
                            onClick={()=>SelectItem(item)}
                            onDoubleClick={()=>selectItemEditable(item)}
                            data-testid={`droped-field-${i}`}
                            className={`${item.fieldTypeId == InputType.TABLE?"templateField__body__tablebox":"templateField__body__box"} 
                            ${i === createTemplateState.dragedFrom ? " templateField__body__from" : ""}
                            ${i === createTemplateState.dropedTo ? " templateField__body__tobackground" : ""}
                            ${item.elementId == createTemplateState.selectedTemplateField?.elementId &&
                                item.caption == createTemplateState.selectedTemplateField?.caption ?" templateField__body__selected":""}
                            `}
                            data-index={JSON.stringify({...item, index: i})}
                            onDragStart={e => setFromIndex(e)}
                            onDragOver={e => dragOver(e)} 
                            onDragLeave={(e)=> dragLeaveInput(e)}>
                                <div className={` ${i === createTemplateState.dropedTo &&
                                    createTemplateState.dropedTo !== createTemplateState.dragedFrom ? " templateField__body__to" :
                                         "templateField__body__box__element"}`}>
                                            <div className="templateField__body__box__label">
                                                {item.isEditable && !item.fixed && item.fieldTypeId !== InputType.TABLE?
                                                    <TextField
                                                        type="text"
                                                        fullWidth
                                                        autoComplete='off'
                                                        placeholder='Type your Label Name'
                                                        value = {newCaptionName }
                                                        onChange = {(e:any)=>{setNewCaptionName(e.target.value);setIsRequired(false)}}
                                                        onBlur={(e:any) => handleUserDefinedChange(e,item)}
                                                    /> 
                                                    :
                                                    <Tooltip 
                                                         title={item.elementId === FIXED_FIELDS.SUBJECT && 
                                                        item.metadata?item.metadata?.caption:item.caption} aria-label="caption">
                                                        <span> {item.elementId === FIXED_FIELDS.SUBJECT && item.metadata?.caption ?
                                                        item.metadata?.caption.length>30? `${item.metadata?.caption?.slice(0,30)} . . .`
                                                        :item.metadata.caption:item.caption.length>30?
                                                        `${item.caption.slice(0,30)} . . .`:item.caption}</span>
                                                    </Tooltip>
                                                }
                                                         {item.required && item.fieldTypeId !== InputType.TABLE ?
                                                         (<span className="templateField__body__box__label__required"> *</span>):("")}
                                                         {item.fixed?(
                                                         <Tooltip title="This field cannot be renamed or deleted">
                                                            <span className="templateField__body__box__label__fixed">FIXED FIELD</span>
                                                        </Tooltip>):("")}
                                                 </div>
                                    <updateFieldContext.Provider value={{refreshList}}>
                                        <FieldRenderer inputField={item} index={i}/>
                                    </updateFieldContext.Provider>
                                    <div className="templateField__body__box__label__error">
                                        {
                                            item?.id === createTemplateState?.selectedTemplateField?.id && (isRequired || isSubject || isDuplicate) ? customErrMsg : ""
                                        }
                                    </div>
                               </div>
                </Grid>
            }
            return "";
            
            })
    }

    const parentragOver=(e: any) => {
        const eve = e as Event;
        eve.stopPropagation();
        eve.preventDefault();
    }

    const onDropMain= async (e: any)=>{
        if(createTemplateState.dragedInput){
            e.preventDefault();
            const items=[...createTemplateState.templateList];
            const tableCount= items.filter((fieldItem: any)=>fieldItem.fieldTypeId === InputType.TABLE)
            if(createTemplateState.dragedInput.id == InputType.TABLE && tableCount.length>4){
                Notification.sendNotification('Max limit of 5 table is exceeded in the current template',AlertTypes.warn);
                createTemplateDispatch(setDragFrom(-1));
                createTemplateDispatch(setDropedTo(-1));
                createTemplateDispatch(setDragedInput(null));
                createTemplateDispatch(setTemplateList([...items]));
                return;
            }
            const to= createTemplateState.dropedTo!==-1?createTemplateState.dropedTo:createTemplateState.templateList.length;
            const names= createTemplateState.templateList.map((item:any)=>item.caption);
            names.push(createTemplateState.dragedInput.fieldType)
            const caption= getUniqueName(names);
            const newItem: TemplateData={
                    id: uuidv4(),
                    fixed:false,
                    caption,
                    required: 0,
                    sequence:items.length+1,
                    elementId:'',
                    fieldTypeId:createTemplateState.dragedInput.id,
                    width: createTemplateState.dragedInput.id == InputType.TABLE?12:6,
                    configListId: -1,
                    updated: false,
                    originalCaption: caption,
                    duplicateCaption: false,
                    autoGenerated: false
            }
            if(newItem.fieldTypeId=== InputType.TABLE){
                    newItem.required= 0;
                    newItem.width= 12;
                    newItem.metadata= constructTableData();
            }
            items.splice(to, 0, newItem);
            createTemplateDispatch(setTemplateList([...items]));
            if(!state.editMode){
                dispatch(setEditMode(true));
            }
            createTemplateDispatch(setDragedInput(null));
            if(-1 !== createTemplateState.dragedFrom){
                createTemplateDispatch(setDragFrom(-1));
            }
            if(-1 !== createTemplateState.dropedTo){
                createTemplateDispatch(setDropedTo(-1));
            }
        }
        else  if(createTemplateState.dropedTo>=0){
            const items=[...createTemplateState.templateList];
            const dropedItem= items.splice(createTemplateState.dragedFrom, 1)[0];
            items.splice(createTemplateState.dropedTo, 0, dropedItem);
            createTemplateDispatch(setTemplateList(items));
            if(!state.editMode){
                dispatch(setEditMode(true));
            }
            if(-1 !== createTemplateState.dragedFrom){
                createTemplateDispatch(setDragFrom(-1));
            }
            if(-1 !== createTemplateState.dropedTo){
                createTemplateDispatch(setDropedTo(-1));
            }
        }
    }

    const refreshList=()=>{
        if(props && props.refreshFields)
        props.refreshFields();
    }

    return (
        <>
        <AutoGeneratedFields autoGeneratedFields={createTemplateState.autoGeneratedFields}/>
        <TemplateName/>
        {nonAutoGeneratedField.length===0?(
            <div className="templateField__dropzone"  draggable="true"
            onDragOver={parentragOver} onDrop={(e)=>onDropMain(e)}>
                    Drop fields to create new template
            </div>
        ):(
            <div className="templateField" onDrop={(e)=>onDropMain(e)} data-testid="drop-zone"
                 onDragOver={parentragOver}  onDragEnd={(e)=>dragLeave(e)}>
                <Grid container className="templateField__body">
                 {renderInputFields()}
            </Grid>
            </div>
        )}
        </>
    )
}
export default React.memo(TemplateFields);

