import React, { ReactElement, useContext, useEffect, useState } from "react";
import FormControlLabel from "@material-ui/core/FormControlLabel";
import InputLabel from "@material-ui/core/InputLabel";
import Radio from "@material-ui/core/Radio";
import RadioGroup from "@material-ui/core/RadioGroup";
import "./SpecificationSection.scss";
import Accordion from "@material-ui/core/Accordion";
import AccordionSummary from "@material-ui/core/AccordionSummary";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import AccordionDetails from "@material-ui/core/AccordionDetails";
import TextField from "@material-ui/core/TextField";
import Button from "@material-ui/core/Button";
import Select from "@material-ui/core/Select";
import MenuItem from "@material-ui/core/MenuItem";
import { SpecificationLibDetailsContext } from "../../context/SpecificationLibDetailsContext";
import Tooltip from "@material-ui/core/Tooltip";
import WarningIcon from "@material-ui/icons/Warning";
import {
  setSpecificationSectionsDetails,
  setIsAutoUpdate,
  setSectionPageNum,
  setSectionPanelArray,
  setIsPublishDisabled,
  setAutogeneratedNumber,
} from "../../context/SpecificationLibDetailsAction";
import { defaultCategory } from "../../../utils/SpecificationConstants";

// const categories: any = [];
//  let defaultNum=0

function SpecificationSections(): ReactElement {
  const [filterValue, setFilterValue] = useState("show-all");
  const [sectionsData, setsectionsData] = useState<Array<any>>([]);
  const [updateSectionsData, setUpdatesectionsData] = useState<any>({});
  const { SpecificationLibDetailsState, SpecificationLibDetailsDispatch }: any =
    useContext(SpecificationLibDetailsContext);
  const [divisionsLists, setdivisionsLists] = useState<Array<any>>([]);
  const [divisionDetails, setDivisionDetails] = useState<Array<any>>([]);
  const [isMarkedCorrect, setIsMarkedCorrect] = useState(false);
  const [expandedPanel, setExpandedPanel] = React.useState<string | false>(
    false
  );
  const [expandableHover, setExpandableHover] = useState<string | false>(false);

  useEffect(() => {
    if (
      SpecificationLibDetailsState?.specificationSectionsDetails &&
      SpecificationLibDetailsState?.specificationSectionsDetails?.length > 0
    ) {
      const list: any = [];
      const sectionList =
        SpecificationLibDetailsState?.specificationSectionsDetails;
      sectionList.map((item: any) => (item.reviewFlag = false));
      sectionList.forEach((section: any, index: number) => {
        if (
          !section.section_name ||
          !section.section_number ||
          !section.division_name_for_section ||
          !section.division_number_for_section
        ) {
          section.reviewFlag = true;
        } else {
          section.reviewFlag = false;
        }
        section.id = index + 1;
        list.push({ ...section });
        if (section.id === 1) {
          if (!section.autoGenNum) {
            section.autoGenNum = 0;
            // SpecificationLibDetailsDispatch(setAutogeneratedNumber(section.autoGenNum))
          } else {
            SpecificationLibDetailsDispatch(
              setAutogeneratedNumber(section.autoGenNum)
            );
          }
        }
      });

      // list.map((item:any,index:number)=>{
      //     item.id= index
      // })
      if (filterValue === "show-all") {
        const sectionsList = [...list];
        const sortSectionsList = sectionsList?.sort((a: any, b: any) =>
          a.start_pages > b.start_pages
            ? 1
            : b.start_pages > a.start_pages
            ? -1
            : 0
        );
        // const sectionList = sortSectionsList.map((item:any, index:number)=>{
        //     item.id=index
        // })
        setsectionsData(sortSectionsList);
      } else {
        setsectionsData(list);
      }
      validateSectionsDivision();
      updateTabStatus();
    }
  }, [SpecificationLibDetailsState?.specificationSectionsDetails]);

  useEffect(() => {
    if (
      SpecificationLibDetailsState?.specificationDivisionDetails?.length > 0
    ) {
      filterdivisionsLists(
        SpecificationLibDetailsState?.specificationDivisionDetails
      );
      validateSectionsDivision();
      updateTabStatus();
    }
  }, [SpecificationLibDetailsState?.specificationDivisionDetails]);

  // validate if user update the division lists
  const validateSectionsDivision = () => {
    if (
      SpecificationLibDetailsState?.specificationSectionsDetails?.length > 0
    ) {
      const sectionsArray = [
        ...SpecificationLibDetailsState?.specificationSectionsDetails,
      ];
      // const divisionArray = [...SpecificationLibDetailsState?.specificationDivisionDetails]
      if (sectionsArray.length > 0) {
        sectionsArray.forEach((item: any) => {
          // const count = divisionArray.filter((list: any) => list.section_desc === item.division )
          if (!item.section_name || !item.section_number) {
            item.reviewFlag = true;
          } else {
            item.reviewFlag = false;
          }
        });
      }

      //sort the sections based on pagenum
      if (filterValue === "show-all") {
        const sectionsList = [...sectionsArray];
        const sortSectionsList = sectionsList?.sort((a: any, b: any) =>
          a.start_pages > b.start_pages
            ? 1
            : b.start_pages > a.start_pages
            ? -1
            : 0
        );
        uniqueSectionValue(sortSectionsList);
      } else {
        uniqueSectionValue(sectionsArray);
      }
    }
  };

  const filterdivisionsLists = (data: any) => {
    // const res = data.filter((item: any) => item.status === 'viewed');
    const sortCategory = data?.sort((a: any, b: any) =>
      a.name > b.name ? 1 : b.name > a.name ? -1 : 0
    );
    const division = divisionDetails.filter((item: any) => {
      item.division === sortCategory.division;
    });
    //         console.log(division,'division')
    // const newDivisionObj={
    //     division_number:'99',
    //     division_name:'Not a specification'
    // }
    // sortCategory.push(newDivisionObj)
    // let sectionNoCount:any=[]
    //   sortCategory.forEach((section: any) => {
    //            sectionNoCount =  sortCategory.filter((item: any) =>{
    // return item.division_name !== section.division_name
    //            }
    //            );
    //   })

    // console.log(sectionNoCount,'sort category')
    setdivisionsLists(sortCategory);
  };

  const handleSortingChange = (event: any) => {
    setFilterValue(event.target.value);
    if (event.target.value === "show-all") {
      const sectionsList = [...sectionsData];
      const sortSectionsList = sectionsList?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages
          ? 1
          : b.start_pages > a.start_pages
          ? -1
          : 0
      );
      setsectionsData(sortSectionsList);
    }
    if (event.target.value === "not-viewed") {
      const sectionsList = [...sectionsData];

      const filter1 = sectionsList.filter(
        (item: any) => item.status !== "viewed"
      );
      const sortFilter1 = filter1?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages
          ? 1
          : b.start_pages > a.start_pages
          ? -1
          : 0
      );
      const filter2 = sectionsList.filter(
        (item: any) => item.status === "viewed"
      );
      const sortFilter2 = filter2?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages
          ? 1
          : b.start_pages > a.start_pages
          ? -1
          : 0
      );

      const res = [...sortFilter1, ...sortFilter2];
      setsectionsData(res);
    }
    if (event.target.value === "issues") {
      const sectionsList = [...sectionsData];

      const filter1 = sectionsList.filter(
        (item: any) => item.review || item.isInvalidSpecNo || item.reviewFlag
      );
      const sortFilter1 = filter1?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages ? 1 : b.start_pages > a.pagenum ? -1 : 0
      );

      const filter2 = sectionsList.filter(
        (item: any) => !item.review && !item.isInvalidSpecNo
      );
      const sortFilter2 = filter2?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages
          ? 1
          : b.start_pages > a.start_pages
          ? -1
          : 0
      );

      const res = [...sortFilter1, ...sortFilter2];
      setsectionsData(res);
    }
  };

  const handleChangeSectionNo = (e: any, argIndex: number) => {
    setUpdatesectionsData({
      ...updateSectionsData,
      section_number: e.target.value,
    });
  };

  const handleChangeSectionName = (e: any, argIndex: number) => {
    setUpdatesectionsData({
      ...updateSectionsData,
      section_name: e.target.value,
    });
  };

  const handleChangeSpecificationDivision = (e: any, argIndex: number) => {
    const changedDivision = e.target.value;
    const divisionValue = changedDivision.split("-");
    sectionsData[argIndex].division_number_for_section = divisionValue[0];
    sectionsData[argIndex].division_name_for_section = divisionValue[1];
    setsectionsData([...sectionsData]);
    updateSectionsDetails();
    updateValue();
  };

  //onblur update save the data to context
  const onSectionsFeildBlur = (argIndex: number) => {
    if (
      sectionsData[argIndex].section_name !== updateSectionsData.section_name ||
      sectionsData[argIndex].section_number !==
        updateSectionsData.section_number
    ) {
      sectionsData[argIndex].section_name = updateSectionsData.section_name;
      sectionsData[argIndex].section_number = updateSectionsData.section_number;
      setsectionsData([...sectionsData]);
      updateValue();
    }
  };

  const updateValue = () => {
    updateSectionsDetails();
    updateTabStatus();
  };

  const handleViewed = (
    e: any,
    expanded: boolean,
    index: number,
    section: any
  ) => {
    e.preventDefault();
    e.stopPropagation();
    if (expanded) {
      setExpandedPanel(section?.id);
      setUpdatesectionsData(sectionsData[index]);
      if (section.status !== "viewed") {
        const sectionsList = [...sectionsData];
        sectionsList[index].status = "viewed";
        setsectionsData(sectionsList);
        updateSectionsDetails();
      }
      // avoid extra API call
      //    const s3Key = SpecificationLibDetailsState.specificationLibDetails[0].sourceKey.replace('.pdf','/pdfpages/')
      //    const sectionS3key=`${s3Key}`+`${section.start_pages}.pdf`
      //    console.log(typeof(section.start_pages),'type')
      //    if(SpecificationLibDetailsState?.parsedFileUrl?.s3Key !== sectionS3key ){
      //         //fetchSectionUrl(section,sectionS3key);
      //    }
      setTimeout(() => {
        if (section.start_pages === "-999") {
          SpecificationLibDetailsDispatch(setSectionPageNum(1));
        } else {
          SpecificationLibDetailsDispatch(
            setSectionPageNum(section.start_pages)
          );
        }
      }, 500);
    } else {
      setExpandedPanel(false);
    }
  };

  // const fetchSectionUrl = (file: any, s3Key: any) => {
  //     const payload = [{
  //         fileName: `${file.start_pages}.pdf`,
  //         key: s3Key,
  //         expiresIn: 1000,
  //         processed: true
  //     }];

  //     getSectionUrl(payload);
  // }

  // const getSectionUrl = async (payload: any) => {
  //     try {
  //         // dispatch(setIsLoading(true));
  //         const fileUploadResponse = await postApi('V1/S3/downloadLink', payload);
  //         if(fileUploadResponse.success){
  //             const fileData = {
  //                 s3Key: payload[0].key,
  //                 url: fileUploadResponse.success[0].url
  //             }
  //             SpecificationLibDetailsDispatch(setParsedFileUrl(fileData));
  //         }
  //         // dispatch(setIsLoading(false));
  //     } catch (error) {
  //         Notification.sendNotification(error, AlertTypes.warn);
  //         // dispatch(setIsLoading(false));
  //     }
  // }

  const handleDeleteSpecification = (index: any) => {
    setExpandedPanel(false);
    const sectionList = [...sectionsData];
    const manipulatedData = sectionList.map((item: any, index: number) => {
      item.id = index;
      return item;
    });

    const filteredData = manipulatedData.filter((item: any) => {
      return item.id !== index;
    });
    setsectionsData(filteredData);
    SpecificationLibDetailsDispatch(setSectionPanelArray(filteredData));
    const sectionData = filteredData.filter((item: any) => item.start_pages);
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sectionData)
    );
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };

  const handleNotSpecificationBtn = (
    argIndex: number,
    notASection: boolean
  ) => {
    const sectionList = [...sectionsData];
    const results = [];
    if (notASection) {
      sectionList.forEach((item: any) => {
        if (item.id === 1) {
          item.autoGenNum =
            +SpecificationLibDetailsState?.autoGeneratedNumber + 1;
        }
      });
      // SpecificationLibDetailsDispatch(setAutogeneratedNumber(SpecificationLibDetailsState?.autoGeneratedNumber+1));

      sectionList[argIndex].section_number =
        "99 00 0" + (SpecificationLibDetailsState?.autoGeneratedNumber + 1);
      sectionList[argIndex].division_number_for_section = "99";
      sectionList[argIndex].section_name = "Not a section";
      sectionList[argIndex].division_name_for_section = "Not a specification";
      SpecificationLibDetailsDispatch(
        setAutogeneratedNumber(
          SpecificationLibDetailsState?.autoGeneratedNumber + 1
        )
      );
      sectionList[argIndex].review = false;
      sectionList[argIndex].reviewFlag = false;
    } else {
      sectionList[argIndex].section_name = "";
      sectionList[argIndex].division_name_for_section = "";
      sectionList[argIndex].division_number_for_section = "";
    }
    // setIsSection(!isSection)
    setsectionsData(sectionList);
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sectionList)
    );
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };

  const updateSectionsDetails = () => {
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sectionsData)
    );
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };
  const updateTabStatus = () => {
    let isPublishedDisabled = false;
    SpecificationLibDetailsState?.specificationSectionsDetails.forEach(
      (section: any) => {
        if (section.review) {
          //   SpecificationLibDetailsDispatch(setDivisionsTabStatus(false));
          //   SpecificationLibDetailsDispatch(setSectionsTabStatus(false));
          isPublishedDisabled = true;
        }
      }
    );
    SpecificationLibDetailsDispatch(setIsPublishDisabled(isPublishedDisabled));

    //else if (
    //       !SpecificationLibDetailsState?.specificationSectionsDetails
    //         .section_name ||
    //       !SpecificationLibDetailsState?.specificationSectionsDetails
    //         .section_number ||
    //       !SpecificationLibDetailsState?.specificationSectionsDetails
    //         .division_name_for_section ||
    //       !SpecificationLibDetailsState?.specificationVersionDetails
    //         ?.Set_Title ||
    //       !SpecificationLibDetailsState?.specificationVersionDetails
    //         ?.Set_Version_Name ||
    //       !SpecificationLibDetailsState?.specificationVersionDetails
    //         ?.Set_Version_Date
    //     ) {
    //       SpecificationLibDetailsDispatch(setDivisionsTabStatus(true));
    //       SpecificationLibDetailsDispatch(setSectionsTabStatus(true));
    //       SpecificationLibDetailsDispatch(setIsPublishDisabled(true));
    //     }
    //   }
    // );
    // if (
    //   !SpecificationLibDetailsState?.specificationVersionDetails?.Set_Title ||
    //   !SpecificationLibDetailsState?.specificationVersionDetails
    //     ?.Set_Version_Name ||
    //   !SpecificationLibDetailsState?.specificationVersionDetails
    //     ?.Set_Version_Date
    // ) {
    //   SpecificationLibDetailsDispatch(setIsPublishDisabled(true));
    //   SpecificationLibDetailsDispatch(setDivisionsTabStatus(true));
    //   SpecificationLibDetailsDispatch(setSectionsTabStatus(true));
    // } else {
    //   SpecificationLibDetailsDispatch(setDivisionsTabStatus(false));
    //   SpecificationLibDetailsDispatch(setIsPublishDisabled(false));
    // }
  };

  const handleMarkAsCorrect = (argIndex: number) => {
    const sectionList = [...sectionsData];
    if (
      !sectionList[argIndex].name ||
      !sectionList[argIndex].number ||
      !sectionList[argIndex].division_name_for_section ||
      sectionList[argIndex].division_number_for_section
    ) {
      sectionList[argIndex].reviewFlag = true;
    }

    sectionList[argIndex].reviewFlag = false;
    sectionList[argIndex].review = false;
    updateValue();
  };
  // unique section_num and section_name validation
  const uniqueSectionValue = (data: any) => {
    data.forEach((section: any) => {
      const sectionNoCount = data.filter(
        (item: any) =>
          section.section_number &&
          item.section_number === section.section_number
      );
      const filteredSectionname = data.filter(
        (item: any) => section.section_name !== "Not a section"
      );
      const section_nameCount = filteredSectionname.filter(
        (item: any) =>
          section.section_name && item.section_name === section.section_name
      );

      sectionNoCount.length > 1
        ? (section.isInvalidSpecNo = true)
        : (section.isInvalidSpecNo = false);
      section_nameCount.length > 1
        ? (section.isInvalidsection_name = true)
        : (section.isInvalidsection_name = false);
    });
    setsectionsData(data);
  };
  return (
    <div className="sections">
      <div className="sections__sort">
        <InputLabel required={false}>Sort by </InputLabel>
        <div className="sections__sort__radio-grouping">
          <RadioGroup
            aria-label="sort-filter"
            name="catefories"
            value={filterValue}
            onChange={handleSortingChange}
          >
            <FormControlLabel
              value="show-all"
              control={<Radio color={"primary"} />}
              label="Show All"
            />
            <FormControlLabel
              value="not-viewed"
              control={<Radio color={"primary"} />}
              label="Not Viewed"
            />
            <FormControlLabel
              value="issues"
              control={<Radio color={"primary"} />}
              label="Issues"
            />
          </RadioGroup>
        </div>
      </div>
      <div className="sections__lists">
        {sectionsData?.length > 0 &&
          sectionsData?.map((item: any, index: number) => (
            <div
              className="sections__lists__item"
              key={`${item.pdfs3key}-${index}`}
            >
              <Accordion
                TransitionProps={{ unmountOnExit: true }}
                expanded={expandedPanel === item.id}
                onChange={(e: any, expanded: any) =>
                  handleViewed(e, expanded, index, item)
                }
              >
                <AccordionSummary
                  expandIcon={
                    expandableHover === item.id ? (
                      <ExpandMoreIcon className="sections__lists__item__expandIcon" />
                    ) : (
                      ""
                    )
                  }
                  onMouseOver={() => setExpandableHover(item.id)}
                  aria-controls="panel-header"
                  id={`panel-header-${index}`}
                >
                  {/* <Typography className={classes.heading}> */}
                  <div className="sections__lists__item__name">
                    <div>
                      <span className="sections__lists__item__index">
                        {index + 1}. &nbsp;
                      </span>
                      {/* <Tooltip title={`${item?.section_name}`} aria-label="delete category"> */}
                      <label>
                        {item?.section_name && item?.section_name.length > 35
                          ? `${
                              item?.section_number
                            } - ${item?.section_name.slice(0, 32)} . . .`
                          : `${item?.section_number} - ${item?.section_name}`}
                      </label>
                      {/* </Tooltip> */}
                    </div>
                    <div className="sections__lists__item__name__action">
                      <>
                        {(item.review ||
                          item.isInvalidSpecNo ||
                          item.reviewFlag) && (
                          <Tooltip
                            title={"Invalid"}
                            aria-label="delete division"
                          >
                            <label>
                              <WarningIcon className="error" />
                            </label>
                          </Tooltip>
                        )}
                        {!item.review &&
                          !item.isInvalidSpecNo &&
                          !item.reviewFlag &&
                          divisionsLists.length > 1 &&
                          !item.division_number_for_section && (
                            <Tooltip
                              title={"Division is not selected"}
                              aria-label="delete division"
                            >
                              <label>
                                <WarningIcon className="error" />
                              </label>
                            </Tooltip>
                          )}
                      </>
                      <>
                        {item.status === "viewed" ? (
                          <span className="text">{item.status}</span>
                        ) : (
                          // <Tooltip title={'Mark as viewed'} aria-label="delete category">
                          //     <label>
                          //         <VisibilityOffIcon className="view" onClick={(e: any) => handleViewed(e, index)}/>
                          //     </label>
                          // </Tooltip>
                          ""
                        )}
                      </>
                    </div>
                  </div>
                  {/* </Typography> */}
                </AccordionSummary>
                <AccordionDetails>
                  <div className="sections__lists__item__details">
                    <form className="sections__lists__item__details__form">
                      <div className="sections__lists__item__details__form__field">
                        <InputLabel required={true}>Section number </InputLabel>
                        <div className="sections__lists__item__details__form__field__input-field">
                          <TextField
                            type="text"
                            fullWidth
                            autoComplete="search"
                            placeholder="Enter section number"
                            variant="outlined"
                            value={updateSectionsData.section_number}
                            onChange={(e) => handleChangeSectionNo(e, index)}
                            onBlur={() => onSectionsFeildBlur(index)}
                          />
                          <div className="sections__lists__item__details__form__field__error-wrap">
                            {item.section_number && item.isInvalidSpecNo && (
                              <p className="sections__lists__item__details__form__field__error-wrap__message">
                                Section number already exists in other section
                              </p>
                            )}
                          </div>
                        </div>
                      </div>

                      <div className="sections__lists__item__details__form__field">
                        <InputLabel required={true}>Section Name </InputLabel>
                        <div className="sections__lists__item__details__form__field__input-field">
                          <TextField
                            type="text"
                            fullWidth
                            autoComplete="search"
                            placeholder="Enter section name"
                            variant="outlined"
                            value={updateSectionsData.section_name}
                            onChange={(e) => handleChangeSectionName(e, index)}
                            onBlur={() => onSectionsFeildBlur(index)}
                          />
                          {/* <div className="sections__lists__item__details__form__field__error-wrap">
                                                        {
                                                             item.section_name && item.isInvalidsection_name && (
                                                                <p className="sections__lists__item__details__form__field__error-wrap__message">
                                                                    Drawing Name already exists in other sheet
                                                                </p>
                                                              )
                                                            }
                                                    </div> */}
                        </div>
                      </div>

                      <div className="sections__lists__item__details__form__field">
                        <InputLabel required={true}>Division </InputLabel>
                        <div className="sections__lists__item__details__form__field__input-field">
                          <Select
                            id={`category-${index}`}
                            fullWidth
                            autoComplete="search"
                            variant="outlined"
                            placeholder="select a value"
                            value={
                              item.division_number_for_section +
                              "-" +
                              item.division_name_for_section
                            }
                            defaultValue=""
                            onChange={(e: any) =>
                              handleChangeSpecificationDivision(e, index)
                            }
                            disabled={
                              item.division_name_for_section ===
                              "Not a specification"
                            }
                          >
                            {divisionsLists?.map(
                              (category: any, categoryIndex: number) => (
                                <MenuItem
                                  key={`${category.division_number}-${categoryIndex}`}
                                  value={
                                    category.division_number +
                                    "-" +
                                    category.division_name
                                  }
                                >
                                  {category.division_number +
                                    "-" +
                                    category.division_name}
                                </MenuItem>
                              )
                            )}
                            {
                              <MenuItem
                                value={defaultCategory.NOT_A_SPECIFICATION}
                                disabled={true}
                              >
                                {defaultCategory.NOT_A_SPECIFICATION}
                              </MenuItem>
                            }
                          </Select>
                          <div className="sections__lists__item__details__form__field__error-wrap">
                            <p className="createCompany__error-wrap__message"></p>
                          </div>
                        </div>
                      </div>

                      <div className="sections__lists__item__details__form__action">
                        {item.review && (
                          <Button
                            // type="submit"
                            data-testid={"submit-version-review"}
                            variant="outlined"
                            className="btn-primary"
                            // disabled={isDisableCreateBtn || companyDetailsState.companyValidation ||
                            // companyDetailsState.companyIDValidation}
                            onClick={() => handleMarkAsCorrect(index)}
                            disabled={item.reviewFlag}
                          >
                            Issue Resolved
                          </Button>
                        )}
                        {item.section_name === "Not a section" ? (
                          <Button
                            // type="submit"
                            data-testid={"submit-version-review"}
                            variant="outlined"
                            className="btn-primary"
                            // disabled={isDisableCreateBtn || companyDetailsState.companyValidation ||
                            // companyDetailsState.companyIDValidation}
                            onClick={() =>
                              handleNotSpecificationBtn(index, false)
                            }
                          >
                            This is a section
                          </Button>
                        ) : (
                          <Button
                            // type="submit"
                            data-testid={"submit-version-review"}
                            variant="outlined"
                            className="btn-primary"
                            // disabled={isDisableCreateBtn || companyDetailsState.companyValidation ||
                            // companyDetailsState.companyIDValidation}
                            onClick={() =>
                              handleNotSpecificationBtn(index, true)
                            }
                          >
                            This is not a section
                          </Button>
                        )}
                        <Button
                          className="btn-primary"
                          onClick={() => handleDeleteSpecification(index)}
                        >
                          Delete
                        </Button>
                      </div>
                    </form>
                  </div>
                </AccordionDetails>
              </Accordion>
            </div>
          ))}
      </div>
    </div>
  );
}
export default React.memo(SpecificationSections);
