/* eslint-disable max-len */
import Button from "@material-ui/core/Button";
import IconButton from "@material-ui/core/IconButton";
import React, { ReactElement, useContext, useEffect, useState } from "react";
import { match, useHistory, useRouteMatch } from "react-router-dom";
import Tooltip from "@material-ui/core/Tooltip";
import { client } from "../../../../../services/graphql";
import { specificationRoles } from "../../../../../utils/role";
import { setIsLoading } from "../../../../root/context/authentication/action";
import { stateContext } from "../../../../root/context/authentication/authContext";
import SpecificationHeaders from "../../components/SpecificationHeaders/SpeecificationHeaders";
import SpecificationSheetsMain from "../../components/SpecificationSheetsMain/SpecificationSheetsMain";
import {
  FETCH_DOCUMENT_LIBRARY_DATA,
  FETCH_PUBLISHED_DOCUMENT_LIBRARY_DATA,
  UPDATE_DOCUMENT_LIBRARY,
  UPDATE_DOCUMENT_LIBRARY_STATUS,
  PUBLISH_SPECIFICATION,
  UPDATE_SUBMITTAL_EXTRACTION,
  FETCH_PROJECT_USERS_LIST
} from "../../graphql/queries/specification";
import Notification, {
  AlertTypes,
} from "../../../../shared/components/Toaster/Toaster";
import "./SpecificationReview.scss";
import { SpecificationLibDetailsContext } from "../../context/SpecificationLibDetailsContext";
import {
  setSpecificationLibDetails,
  setIsPublishDisabled,
  setParsedFileUrl,
  setPublishedSpecificationLists,
  setSectionPanelArray,
  setSpecificationSectionsDetails,
  setIsAutoUpdate,
  setSectionPageNum,
  setThumbnailUrl,
  setAutogeneratedNumber,
  setSubmittalTriggerResponse,
} from "../../context/SpecificationLibDetailsAction";
import PdfTron from "../../components/PdfTron/PdfTron";
import { postApi } from "../../../../../services/api";
import { Grid, Paper, Box } from "@material-ui/core";
import CloseIcon from "@material-ui/icons/Close";
import Popover from "@material-ui/core/Popover";
import InputLabel from "@material-ui/core/InputLabel";
import TextField from "@material-ui/core/TextField";
import MoreVertIcon from "@material-ui/icons/MoreVert";
import Menu from "@material-ui/core/Menu";
import MenuItem from "@material-ui/core/MenuItem";
import { Droppable, DragDropContext, Draggable } from "react-beautiful-dnd";
import ViewAgendaIcon from "@material-ui/icons/ViewAgenda";
import moment from "moment";
import LazyLoad from "react-lazyload";
import { axiosApiInstance } from 'src/services/api';
import { decodeExchangeToken } from 'src/services/authservice';
// import { PublishEmailTemplate } from 'src/modules/specification/templates/publish';
import {PublishEmailTemplate} from 'src/modules/specification/templates/publish';
import { myProjectRole, projectFeatureAllowedRoles } from '../../../../../utils/role';
import { features } from 'src/utils/constants';

export interface Params {
  projectId: string;
  documentId: string;
}

const NOTIFICATION_URL: any = process.env["REACT_APP_NOTIFICATION_URL"];
const NOTIFICATION_PATH = "V1/notification";
let processedUrl: any = [];
export default function SpecificationReview(): ReactElement {
  const history = useHistory();
  const pathMatch: match<Params> = useRouteMatch();
  const { dispatch, state }: any = useContext(stateContext);
  const { SpecificationLibDetailsState, SpecificationLibDetailsDispatch }: any =
    useContext(SpecificationLibDetailsContext);
  const [fileName, setFileName] = useState<any>({ name: "", description: "" });
  const [openSectionPanel, setOpenSectionPanel] = useState(true);
  const [sectionPanelList, setSectionPanelList] = useState<Array<any>>([]);
  const [totalPage, setTotalPage] = useState<any>(1162);
  const [anchorEl, setAnchorEl] = React.useState<HTMLButtonElement | null>(
    null
  );
  const [anchorEl1, setAnchorEl1] = React.useState<HTMLButtonElement | null>(
    null
  );
  const [anchorEl2, setAnchorEl2] = React.useState<HTMLButtonElement | null>(
    null
  );
  const [newSectionName, setNewSectionName] = useState("");
  const [newSectionNumber, setNewSectionNumber] = useState("");
  const [trimSectionName, setTrimSectionName] = useState("");
  const [trimSectionNumber, setTrimSectionNumber] = useState("");
  const [sectionsList, setSectionsList] = useState<Array<any>>([]);
  const [selectedThumbnail, setSelectedThumbnail] = useState<any>(null);
  const open = Boolean(anchorEl);
  const open1 = Boolean(anchorEl1);
  const open2 = Boolean(anchorEl2);
  const id = open ? "simple-popover" : undefined;
  const [openIndex, setOpenIndex] = useState(-1);
  const [openSecIndex, setOpenSecIndex] = useState(-1);
  // const [processedUrl, setProcessedUrl] = useState<Array<any>>([]);
  const [specSectionDetails, setSpecSectionDetails] = useState<any>([]);
  const [usersList, setUsersList] = useState<Array<any>>([]);
  useEffect(() => {
    return () => {
      processedUrl = [];
    };
  }, []);
  useEffect(() => {
    if (
      state.selectedProjectToken &&
      state?.projectFeaturePermissons?.canviewSpecifications
    ) {
      fetcPublishedSpecificationLibrary();
      fetchSpecificationLibraryDetails();
      fetchProjectUsers();
    }
  }, [state.selectedProjectToken, pathMatch.params.documentId]);
  useEffect(() => {
    if (
      SpecificationLibDetailsState.specificationLibDetails.length > 0 &&
      SpecificationLibDetailsState.isAutoUpdate
    ) {
      updateSpecificationLibrary(false);
    }
  }, [
    SpecificationLibDetailsState?.specificationDivisionDetails,
    SpecificationLibDetailsState?.specificationSectionsDetails,
    SpecificationLibDetailsState?.specificationVersionDetails,
    SpecificationLibDetailsState?.specificationLibDetails,
  ]);
  useEffect(() => {
    if (SpecificationLibDetailsState.specificationLibDetails.length > 0) {
      setTotalPage(
        SpecificationLibDetailsState?.specificationLibDetails[0]?.sectionInfo
          ?.total_pages
      );
      fetchThumbnailUrl(
        SpecificationLibDetailsState?.specificationLibDetails[0]?.sectionInfo
          ?.s3key_thumbnails
      );
    }
  }, [SpecificationLibDetailsState?.specificationLibDetails]);

  useEffect(() => {
    if (
      SpecificationLibDetailsState?.specificationSectionsDetails?.length > 0
    ) {
      validateSheetData(
        SpecificationLibDetailsState?.specificationSectionsDetails
      );
      setSectionsList(
        SpecificationLibDetailsState?.specificationSectionsDetails
      );
    }
  }, [SpecificationLibDetailsState?.specificationSectionsDetails]);

  useEffect(() => {
    return () => {
      SpecificationLibDetailsDispatch(setAutogeneratedNumber(0));
    };
  }, []);


  const fetchProjectUsers = async () => {
    try {
        const projectTeammatesResponse= await client.query({
            query:FETCH_PROJECT_USERS_LIST,
            variables:{
                projectId: Number(pathMatch.params.projectId),
                featureId: [5]
            },
            fetchPolicy: 'network-only',
            context:{role: myProjectRole.viewMyProjects }
            });
        const users: Array<any> =[];
         projectTeammatesResponse?.data.projectAssociation.forEach((item: any)=>{
            const userItem= {
                id: item?.user?.id,
                firstName:item?.user?.firstName,
                lastName:item?.user?.lastName,
                email: item?.user?.email,
                status: item?.status
            }
            users.push(userItem);
        });
        setUsersList(users);
    } catch (error : any) {
        console.log(error);
    }
}

  //fetch specification libraries
  const fetchSpecificationLibraryDetails = async () => {
    try {
      dispatch(setIsLoading(true));
      const documentLibraryResponse = await client.query({
        query: FETCH_DOCUMENT_LIBRARY_DATA,
        variables: {
          specificationId: pathMatch.params.documentId,
        },
        fetchPolicy: "network-only",
        context: {
          role: specificationRoles.viewSpecifications,
          token: state.selectedProjectToken,
        },
      });
      const documentLibraryDetails: any = [];
      if (documentLibraryResponse?.data?.techspecUploadStatus.length > 0) {
        documentLibraryResponse?.data?.techspecUploadStatus.forEach(
          (document: any) => {
            documentLibraryDetails.push(document);
            const headerInfo = { ...fileName, name: document.fileName };
            setFileName(headerInfo);
          }
        );
        SpecificationLibDetailsDispatch(
          setSpecificationLibDetails(
            JSON.parse(JSON.stringify(documentLibraryDetails))
          )
        );
        setSpecSectionDetails(documentLibraryDetails[0]);
      }
      dispatch(setIsLoading(false));
    } catch (error: any) {
      console.log(error);
      if (error?.toString().includes("invalid input syntax for type uuid")) {
        setTimeout(() => {
          history.push(
            `/specifications/projects/${pathMatch.params.projectId}/library`
          );
        }, 1000);
      }
      Notification.sendNotification(error, AlertTypes.warn);
      dispatch(setIsLoading(false));
    }
  };

  // const fetchSheetUrl = (file: any, fileName: any) => {
  //   const payload = [
  //     {
  //       fileName: fileName,
  //       key: file,
  //       expiresIn: 100000,
  //     },
  //   ];
  //   getSheetUrl(payload);
  // };

  // const getSheetUrl = async (payload: any) => {
  //   try {
  //     dispatch(setIsLoading(true));
  //     const fileUploadResponse = await postApi("V1/S3/downloadLink", payload);
  //     if (fileUploadResponse.success) {
  //       const fileData = {
  //         s3Key: payload[0].key,
  //         url: fileUploadResponse.success[0].url,
  //       };
  //       SpecificationLibDetailsDispatch(setParsedFileUrl(fileData));
  //     }
  //     dispatch(setIsLoading(false));
  //   } catch (error) {
  //     Notification.sendNotification(error, AlertTypes.warn);
  //     dispatch(setIsLoading(false));
  //   }
  // };

  const navigateBack = () => {
    history.push(
      `/specifications/projects/${pathMatch.params.projectId}/library`
    );
  };

  const updateSpecificationLibrary = async (isLoader: boolean) => {
    try {
      dispatch(setIsLoading(true));
      const versionInfo: any = {
        versionInfo: {
          Set_Title: SpecificationLibDetailsState.specificationVersionDetails
            ?.Set_Title
            ? SpecificationLibDetailsState.specificationVersionDetails
                ?.Set_Title
            : "",
          Version_Date: SpecificationLibDetailsState.specificationVersionDetails
            ?.Version_Date
            ? SpecificationLibDetailsState.specificationVersionDetails
                ?.Version_Date
            : "",
          Set_Version_Name: SpecificationLibDetailsState
            .specificationVersionDetails?.Set_Version_Name
            ? SpecificationLibDetailsState.specificationVersionDetails
                ?.Set_Version_Name
            : "",
        },
      };
      const updateSpecificationResponse: any = await client.mutate({
        mutation: UPDATE_DOCUMENT_LIBRARY,
        variables: {
          id: pathMatch.params.documentId,
          divisionsReviewed: {
            divisions:
              SpecificationLibDetailsState.specificationDivisionDetails,
          },
          sectionInfoReviewed: {
            sections: SpecificationLibDetailsState.specificationSectionsDetails,
          },
          versionInfoReviewed: versionInfo,
          status: "REVIEWING",
        },
        context: {
          role: specificationRoles.updateSpecifications,
          token: state.selectedProjectToken,
        },
      });
      if (
        updateSpecificationResponse?.data?.update_techspecUploadStatus
          ?.affected_rows > 0 &&
        isLoader
      ) {
        Notification.sendNotification(
          "Document updated successfully",
          AlertTypes.success
        );
        history.push(
          `/specifications/projects/${pathMatch.params.projectId}/lists`
        );
      }
      dispatch(setIsLoading(false));
    } catch (err: any) {
      dispatch(setIsLoading(false));
      Notification.sendNotification(err, AlertTypes.warn);
      console.log(err);
    }
  };

  const handlePublishSpecification = () => {
    const payload: any = [];
    const sectionsData = [
      ...SpecificationLibDetailsState.specificationSectionsDetails,
    ];
    const filteredSectionData = sectionsData.filter((item: any) => {
      return item.section_name !== "Not a section";
    });
    const versionInfo =
      SpecificationLibDetailsState.specificationVersionDetails;

    const momentDate = versionInfo.Version_Date
      ? moment(versionInfo.Version_Date).format("DD-MMM-YYYY")
      : "";
    const momentUtc = momentDate
      ? moment(momentDate).format("YYYY-MM-DDTHH:mm:ss.SSS[Z]")
      : "";
    const resDate = momentUtc && momentUtc !== "Invalid date" ? momentUtc : "";
    filteredSectionData.forEach((section: any) => {
      const sectionDetails = {
        divisionName: section.division_name_for_section,
        divisionNumber: section.division_number_for_section,
        endPage: section.end_pages,
        fileName:
          SpecificationLibDetailsState.specificationLibDetails[0].fileName,
        sectionNumber: section.section_number,
        sectionName: section.section_name,
        sourceId: pathMatch.params.documentId,
        sourceKey:
          SpecificationLibDetailsState.specificationLibDetails[0].sourceKey,
        startPage: section.start_pages,
        title: versionInfo.Set_Title,
        versionDate: resDate,
        versionName: versionInfo.Set_Version_Name,
      };
      payload.push(sectionDetails);
    });
    publishDocument(payload);
  };

  const publishDocument = async (payload: any) => {
    try {
      dispatch(setIsLoading(true));
      notifyProjectUsers();
      const publishResponse: any = await client.mutate({
        mutation: PUBLISH_SPECIFICATION,
        variables: {
          objects: payload,
        },
        context: {
          role: specificationRoles.createSpecifications,
          token: state.selectedProjectToken,
        },
      });
      if (publishResponse.data.insert_techspecSections.affected_rows > 0) {
        Notification.sendNotification(
          "Specification is published successfully",
          AlertTypes.success
        );
        triggerSubmittal(pathMatch.params.documentId);
        updateSpecificationLibraryStatus();
      } else {
        Notification.sendNotification(
          "Something went wrong. Please check extracted specifications",
          AlertTypes.success
        );
      }
      dispatch(setIsLoading(false));
    } catch (err: any) {
      dispatch(setIsLoading(false));
      Notification.sendNotification(
        "Publish failed. Specification title, version and date combination already exists.",
        AlertTypes.warn
      );
      console.log(err);
    }
  };

  const frameEmailPayload=()=>{
    const users = [...usersList];
    const selectedUsers = users?.filter((user: any) => decodeExchangeToken().userId !== user.id)
    ?.map((item: any) => ({id: item.id, email: item.email}));
    const host= `${location.protocol}//${location.host}`;
    const redirectionUrl = `${host}/drawings/projects/${pathMatch.params.projectId}/pdf-viewer/${pathMatch.params.documentId}?tenant-id=${decodeExchangeToken().tenantId}`;
    // const currentDrawing = DrawingLibDetailsState?.drawingSheetLists.find((item: any)=> item.id == pathMatch.params.documentId);
    const currentProject = state.projectList.find((item: any)=> item.projectId == pathMatch.params.projectId);
    const htmlEmail= PublishEmailTemplate({
      projectName: currentProject?.projectName || '',
      specificationName: fileName?.name ||'Specification.pdf',
      userName: decodeExchangeToken().userName,
      versionName: SpecificationLibDetailsState.specificationVersionDetails?.Set_Version_Name?SpecificationLibDetailsState.specificationVersionDetails?.Set_Version_Name:'',
      redirectionUrl
    })
    const payload: any = [{
      users:selectedUsers,
      email: true,
      // eslint-disable-next-line max-len
      emailTemplate: htmlEmail,
      subject: `${decodeExchangeToken().userName} published ${fileName?.name ||'Drawing.pdf'}-${SpecificationLibDetailsState.specificationVersionDetails?.Set_Version_Name?.Set_Version_Name||''}`,
      contentModified: {    
        actionType: "ADDED",    
        featureType: features.SPECIFICATIONS,    
        tenantFeatureId: null,    
        projectFeatureId: 5, 
        projectId: pathMatch.params.projectId, 
        fieldName: "Specification Name",
        oldValue: null,   
        newValue: null,
        navigationUrl: {    
              serviceName: "authentication",    
              path: `/drawings/projects/${pathMatch.params.projectId}/pdf-viewer/${pathMatch.params.documentId}?tenant-id=${decodeExchangeToken().tenantId}`
        }
      }  
    }  
  ]
  return payload;
  }

  const notifyProjectUsers = async () => {
    try {
        const payload= frameEmailPayload();
        dispatch(setIsLoading(true));
        await axiosApiInstance.post(
          `${NOTIFICATION_URL}${NOTIFICATION_PATH}`,
          payload,
          {
            headers: {
              token: "exchange",
            },
          }
        );
    } catch(error: any) {

    }
}

  // call this query inside publish API
  const updateSpecificationLibraryStatus = async () => {
    try {
      dispatch(setIsLoading(true));
      const updateSpecificationResponse: any = await client.mutate({
        mutation: UPDATE_DOCUMENT_LIBRARY_STATUS,
        variables: {
          id: pathMatch.params.documentId,
          status: "PUBLISHED",
        },
        context: {
          role: specificationRoles.updateSpecifications,
          token: state.selectedProjectToken,
        },
      });
      if (
        updateSpecificationResponse?.data?.update_techspecUploadStatus
          ?.affected_rows > 0
      ) {
        history.push(
          `/specifications/projects/${pathMatch.params.projectId}/lists`
        );
      }

      dispatch(setIsLoading(false));
    } catch (err: any) {
      dispatch(setIsLoading(false));
      Notification.sendNotification(err, AlertTypes.warn);
      console.log(err);
    }
  };

  // validate sheet data for publish
  const validateSheetData = (data: any) => {
    const invalidCount = data.filter(
      (item: any) =>
        item.section_name !== "Not a section" &&
        (item.isInvalidSpecNo ||
          item.review ||
          item.reviewFlag ||
          (SpecificationLibDetailsState?.specificationDivisionDetails?.length >
            1 &&
            (!item.division_number_for_section ||
              !item.division_name_for_section)))
    );
    invalidCount.length > 0
      ? SpecificationLibDetailsDispatch(setIsPublishDisabled(true))
      : SpecificationLibDetailsDispatch(setIsPublishDisabled(false));
  };

  //fetch published drawing libraries for validation
  const fetcPublishedSpecificationLibrary = async () => {
    try {
      dispatch(setIsLoading(true));

      const documentLibraryResponse = await client.query({
        query: FETCH_PUBLISHED_DOCUMENT_LIBRARY_DATA,
        variables: {
          status: "PUBLISHED",
        },
        fetchPolicy: "network-only",
        context: {
          role: specificationRoles.viewSpecifications,
          token: state.selectedProjectToken,
        },
      });
      const publishedDocumentList: any = [];
      if (documentLibraryResponse?.data?.techspecUploadStatus.length > 0) {
        documentLibraryResponse?.data?.techspecUploadStatus.forEach(
          (document: any) => {
            publishedDocumentList.push(document);
          }
        );
        SpecificationLibDetailsDispatch(
          setPublishedSpecificationLists(
            JSON.parse(JSON.stringify(publishedDocumentList))
          )
        );
      }

      dispatch(setIsLoading(false));
    } catch (error: any) {
      console.log(error);
      if (error?.toString().includes("invalid input syntax for type uuid")) {
        setTimeout(() => {
          history.push(
            `/specifications/projects/${pathMatch.params.projectId}/library`
          );
        }, 1000);
      }
      Notification.sendNotification(error, AlertTypes.warn);
      dispatch(setIsLoading(false));
    }
  };
  useEffect(() => {
    if (processedUrl.length > 0) {
      sectionPanelDisplay();
    }
  }, [
    processedUrl,
    SpecificationLibDetailsState?.specificationSectionsDetails,
  ]);

  useEffect(() => {
    if (SpecificationLibDetailsState?.sectionPanelArray?.length > 0) {
      setSectionPanelList(SpecificationLibDetailsState?.sectionPanelArray);
    }
  }, [SpecificationLibDetailsState?.sectionPanelArray]);
  const sectionPanelDisplay = () => {
    let pageList: any = [];
    const sortedPageUrl = processedUrl?.sort((a: any, b: any) =>
      a.pageNumber > b.pageNumber ? 1 : b.pageNumber > a.pageNumber ? -1 : 0
    );
    sortedPageUrl.map((item: any) => (item.isDraggableDisabled = true));
    pageList = [...sortedPageUrl];
    if (
      SpecificationLibDetailsState?.specificationSectionsDetails?.length > 0
    ) {
      const sectionList =
        SpecificationLibDetailsState?.specificationSectionsDetails;
      sectionList.map((item: any) => (item.isDraggableDisabled = false));
      const sortSectionsList = sectionList?.sort((a: any, b: any) =>
        a.start_pages > b.start_pages
          ? 1
          : b.start_pages > a.start_pages
          ? -1
          : 0
      );
      const validPages = sortSectionsList.filter(
        (section: any) => section.start_pages > 0
      );
      const inValidPages = sortSectionsList.filter(
        (section: any) => section.start_pages < 0
      );
      validPages.forEach((section: any, index: number) => {
        pageList.splice(section.start_pages - 1 + index, 0, section);
      });

      pageList = [...pageList, ...inValidPages];
    }
    setSectionPanelList(pageList);
    SpecificationLibDetailsDispatch(setSectionPanelArray(pageList));
  };
  //fetching thumbanil
  const fetchThumbnailUrl = async (argS3Key: string) => {
    const payload: any = [];
    const totalPages =
      SpecificationLibDetailsState?.specificationLibDetails[0]?.sectionInfo
        ?.total_pages;

    for (let i = 1; i <= totalPages; i++) {
      // console.log(`${argS3Key}${i}.png`,'`${argS3Key}${i}.png`')
      const payloadObj = {
        fileName: `${argS3Key}${i}.png`,
        key: `${argS3Key}` + `${i}.png`,
        expiresIn: 10000,
        processed: true,
      };
      payload.push(payloadObj);
    }
    const payloadCount = 200;
    const loadCount = Math.ceil(totalPages / payloadCount);
    for (let i = 1; i <= loadCount; i++) {
      const res = payload.splice(0, payloadCount);
      if (res.length > 0) {
        await getThumbnailUrl(res);
      }
    }
  };
  const getThumbnailUrl = async (payload: any) => {
    const data: any = [];
    const pageNumber = payload[0].key
      .split("/")
      [payload[0].key.split("/").length - 1].split(".")[0];
    try {
      const fileUploadResponse = await postApi("V1/S3/downloadLink", payload);
      if (fileUploadResponse.success) {
        for (let i = 0; i < fileUploadResponse.success.length; i++) {
          const fileData = {
            s3Key: payload[i]?.key,
            url: fileUploadResponse.success[i]?.url,
            pageNumber: Number(pageNumber) + i,
          };
          data.push(fileData);
        }
        const result = [...processedUrl, ...data];

        processedUrl = [...result];
        //                 const flags = [], l = value.length;
        // for( let i=0; i<l; i++) {
        //     if( flags[value[i].s3Key]) continue;
        //     flags[value[i].s3Key] = true;
        //     processedUrl.push(value[i]);
        // }
        // console.log(processedUrl,'output')
      }
    } catch (error) {
      for (let i = 0; i < payload.length; i++) {
        const fileData = {
          pageNumber: Number(pageNumber + i),
          s3Key: payload[i]?.key,
          url: "",
        };
        data.push(fileData);
      }
      const result = [...processedUrl, ...data];
      processedUrl = [...result];
      //                 const flags = [], l = processedUrl.length;
      // for( let i=0; i<l; i++) {
      //     if( flags[value[i].s3Key]) continue;
      //     flags[value[i].s3Key] = true;
      //     processedUrl.push(value[i]);
      // }
      Notification.sendNotification(error, AlertTypes.warn);
    }
  };

  const handleSectionPanel = () => {
    setOpenSectionPanel(!openSectionPanel);
  };
  const handlePageClick = (pageNumber: any) => {
    SpecificationLibDetailsDispatch(setSectionPageNum(pageNumber));
  };
  const handleCloseIcon = () => {
    setOpenSectionPanel(!openSectionPanel);
  };
  const handlePopOver = (
    event: React.MouseEvent<HTMLButtonElement>,
    item: any,
    index: number
  ) => {
    setAnchorEl(event.currentTarget);
    setSelectedThumbnail({ item, index });
    setOpenIndex(-1);
  };
  //close popover
  const handleClose = () => {
    setNewSectionName("");
    setNewSectionNumber("");
    setTrimSectionName("");
    setTrimSectionNumber("");
    setAnchorEl(null);
    setAnchorEl1(null);
    setAnchorEl2(null);
  };

  function getNextSectionStartPage(index: number): number | null {
    const panelList = [...sectionPanelList];
    // since we are trying to find the next section, we will start our search from index till the end
    const toSearchInPanelList = panelList.slice(index, panelList.length);
    const nextSection = toSearchInPanelList.find((item: any) => item.id);
    if (nextSection) return nextSection.start_pages;
    return null;
  }

  const addNewSection = () => {
    const { item, index } = selectedThumbnail;
    const startPage = +item?.pageNumber;
    const nextSectionStartPage = getNextSectionStartPage(index);
    let endPage = Number(
      SpecificationLibDetailsState?.specificationLibDetails[0]?.sectionInfo
        ?.total_pages
    );

    if (nextSectionStartPage) {
      endPage = Number(nextSectionStartPage) - 1;
    }

    let newData: any = {
      division_name_for_section: "",
      division_number_for_section: "",
      section_name: trimSectionName.trim(),
      section_number: trimSectionNumber.trim(),
      status: "viewed",
      start_pages: startPage,
      end_pages: endPage,
    };

    let panelList = [...sectionPanelList];
    let sectionList = [...sectionsList];
    const res = sectionList.filter(
      (item: any) =>
        item.section_name?.toLowerCase() ===
        trimSectionName?.toLowerCase()?.trim()
    );
    const resNum = sectionList.filter(
      (item: any) =>
        item.section_number?.toLowerCase() ===
        trimSectionNumber?.toLowerCase()?.trim()
    );
    const resPage = sectionList.filter(
      (item: any) => item.start_pages === startPage
    );
    if (res.length > 0) {
      Notification.sendNotification(
        `Section name '${trimSectionName.trim()}' already exists in the list`,
        AlertTypes.warn
      );
    } else if (resNum.length > 0) {
      Notification.sendNotification(
        `Section number '${trimSectionNumber.trim()}' already exists in the list`,
        AlertTypes.warn
      );
    }
    // else if (resPage.length > 0) {
    //   Notification.sendNotification(
    //     `Start Page '${startPage}' is already exist for present section`,
    //     AlertTypes.warn
    //   );
    // }
    else {
      panelList.push(newData);
      sectionList.push(newData);
      setSectionsList(sectionList);
      setSectionPanelList(panelList);
      // SpecificationLibDetailsDispatch(
      //   setSpecificationSectionsDetails(sectionList)
      // );
      SpecificationLibDetailsDispatch(setSectionPanelArray(panelList));
      SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
      updateEndPage(sectionList, newData.start_pages);
      if (sectionList.length > 2) {
        setNewSectionName("");
        setTrimSectionName("");
        setNewSectionNumber("");
        setTrimSectionNumber("");
        sectionList = [];
        panelList = [];
        newData = null;
        handleClose();
      } else {
        handleClose();
        setNewSectionName("");
        setTrimSectionName("");
        setNewSectionNumber("");
        setTrimSectionNumber("");
        sectionList = [];
        panelList = [];
        newData = null;
      }
    }
  };
  //add new section numbr
  const handleSectionNumChange = (e: any) => {
    setTrimSectionNumber(e.target.value.trim());
    setNewSectionNumber(e.target.value);
  };
  const handleSectionNameChange = (e: any) => {
    setTrimSectionName(e.target.value.trim());
    setNewSectionName(e.target.value);
  };
  const handeMoreClick = (event: any, pageNumber: any) => {
    event.preventDefault();
    event.stopPropagation();
    resetIndex(pageNumber);
    setAnchorEl1(event.currentTarget);
  };
  const resetIndex = (index: any) => {
    if (index === openIndex) {
      setOpenIndex(-1);
    } else {
      setOpenIndex(index);
    }
  };
  const handeSecMoreClick = (event: any, index: any) => {
    resetSecIndex(index);
    setAnchorEl2(event.currentTarget);
  };
  const resetSecIndex = (index: any) => {
    if (index === openSecIndex) {
      setOpenSecIndex(-1);
    } else {
      setOpenSecIndex(index);
    }
  };

  const handleDelete = (index: number) => {
    const sectionList = [...sectionPanelList];
    const manipulatedData = sectionList.map((item: any, index: number) => {
      item.id = index;
      return item;
    });

    const filteredData = manipulatedData.filter((item: any) => {
      return item.id !== index;
    });
    SpecificationLibDetailsDispatch(setSectionPanelArray(filteredData));
    setSectionPanelList(filteredData);
    const sectionData = filteredData.filter((item: any) => item.start_pages);
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sectionData)
    );
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };

  const updateEndPage = (sectionData: any, pageNumber: number) => {
    const sortSectionsList = sectionData?.sort((a: any, b: any) =>
      a.start_pages > b.start_pages ? 1 : b.start_pages > a.start_pages ? -1 : 0
    );
    for (let i = 1; i <= sortSectionsList.length; i++) {
      if (sortSectionsList[i]?.start_pages === pageNumber) {
        sortSectionsList[i - 1].end_pages =
          sortSectionsList[i]?.start_pages - 1;
      }
    }
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sortSectionsList)
    );
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };
  const handleNotASection = (index: number) => {
    const sectionList = [...sectionsList];
    const panelList = [...sectionPanelList];

    if (sectionList[index]) {
      sectionList[index].section_name = "Not a section";
      sectionList[index].section_number = "";
      sectionList[index].division_name_for_section = "";
      sectionList[index].division_number_for_section = "";
    }
    if (panelList[index]) {
      panelList[index].section_name = "Not a section";
      panelList[index].section_number = "";
      panelList[index].division_name_for_section = "";
      panelList[index].division_number_for_section = "";
    }
    SpecificationLibDetailsDispatch(
      setSpecificationSectionsDetails(sectionList)
    );
    SpecificationLibDetailsDispatch(setSectionPanelArray(panelList));
    setOpenSecIndex(-1);
    setSectionsList(sectionList);
    setSectionPanelList(panelList);
    SpecificationLibDetailsDispatch(setIsAutoUpdate(true));
  };
  const handleDragEnd = (result: any) => {
    const { destination, source, draggableId } = result;
    let updatedIndex = 0;
    if (!destination) {
      return;
    } else if (destination.droppableId === "sectionPannel") {
      const panelList = [...sectionPanelList];
      const [selectedSection] = panelList.splice(source.index, 1);
      const dummy = [...panelList];
      const [dropableSection] = dummy.splice(destination.index, 1);
      if (dropableSection.pageNumber) {
        selectedSection.start_pages = dropableSection.pageNumber;
        updatedIndex = dropableSection.pageNumber;
      } else if (dropableSection.start_pages) {
        selectedSection.start_pages = dropableSection.start_pages;
        updatedIndex = dropableSection.start_pages;
      }
      // const filteredData = panelList.filter((item: any) => {
      //   return item.start_pages !== source.index;
      // });
      panelList.splice(destination.index, 0, selectedSection);
      // console.log(panelList)
      setSectionPanelList(panelList);
      SpecificationLibDetailsDispatch(setSectionPanelArray(panelList));
      const sectionData = panelList.filter((item: any) => item.start_pages);
      updateEndPage(sectionData, updatedIndex);
      // }
      // }
    }
  };

  const triggerSubmittal = async (id: any) => {
    try {
      // if(){
      //     // dispatch(setIsLoading(true));
      //     return;
      // }
      // fetchedFilesArray = [];
      dispatch(setIsLoading(true));
      const submittalTriggerResponse = await client.mutate({
        mutation: UPDATE_SUBMITTAL_EXTRACTION,
        variables: {
          submittalId: id,
        },
        context: {
          role: specificationRoles.createSpecifications,
          token: state.selectedProjectToken,
        },
      });
      if (
        submittalTriggerResponse?.data?.submittalProcess?.ack.length > 0 &&
        submittalTriggerResponse?.data?.submittalProcess?.ack.includes(
          "successfully"
        )
      ) {
        SpecificationLibDetailsDispatch(
          setSubmittalTriggerResponse(
            submittalTriggerResponse?.data?.submittalProcess?.ack
          )
        );
        Notification.sendNotification(
          "Submittals Extraction started",
          AlertTypes.success
        );
      }
      // if(isLoader){
      dispatch(setIsLoading(false));
      // }
    } catch (error) {
      console.log(error);
      Notification.sendNotification(error, AlertTypes.warn);
      // if(isLoader){
      dispatch(setIsLoading(false));
      // }
    }
  };

  return (
    <DragDropContext onDragEnd={handleDragEnd}>
      <div className="section-review">
        {state?.projectFeaturePermissons?.cancreateSpecifications ? (
          <>
            <div className="section-review__wrapper">
              <div className="section-review__wrapper__left">
                <div className="section-review__wrapper__left__header">
                  <SpecificationHeaders
                    headerInfo={fileName}
                    navigate={navigateBack}
                  />
                </div>

                <div className="section-review__wrapper__left__pdfDisplay">
                  {SpecificationLibDetailsState.sectionView === "SECTIONS" ? (
                    <div
                      className={`${
                        openSectionPanel
                          ? "section-review__wrapper__left__pdfDisplay__section"
                          : "section-review__wrapper__left__pdfDisplay__section-collapse"
                      }`}
                    >
                      {!openSectionPanel ? (
                        <div className="section-review__wrapper__left__pdfDisplay__section-collapse__closed-section">
                          <div className="section-review__wrapper__left__pdfDisplay__section-collapse__closed-section__text">
                            Section Break
                          </div>
                          <div
                            className="section-review__wrapper__left__pdfDisplay__section-collapse__closed-section__icon"
                            onClick={handleSectionPanel}
                          >
                            <ViewAgendaIcon />
                          </div>
                        </div>
                      ) : (
                        <>
                          <div className="section-review__wrapper__left__pdfDisplay__section__header">
                            <div className="section-review__wrapper__left__pdfDisplay__section__header__text">
                              Section Break
                            </div>
                            <IconButton
                              className="section-review__wrapper__left__pdfDisplay__section__header__closeIcon"
                              onClick={handleCloseIcon}
                            >
                              <CloseIcon />
                            </IconButton>
                          </div>

                          <div className="left-grid">
                            <Droppable droppableId="sectionPannel">
                              {(provided: any) => (
                                <div
                                  {...provided.droppableProps}
                                  ref={provided.innerRef}
                                >
                                  {sectionPanelList?.length > 0 &&
                                    sectionPanelList.map(
                                      (item: any, index: number) => {
                                        return (
                                          <>
                                            <Draggable
                                              key={index}
                                              draggableId={`${index}1`}
                                              index={index}
                                              isDragDisabled={
                                                item.isDraggableDisabled
                                              }
                                            >
                                              {(provided: any) => (
                                                <div
                                                  ref={provided.innerRef}
                                                  {...provided.draggableProps}
                                                  {...provided.dragHandleProps}
                                                >
                                                  {"pageNumber" in item ? (
                                                    <>
                                                      <div
                                                        className={`left-grid__item ${
                                                          item.pageNumber ===
                                                          SpecificationLibDetailsState.sectionPageNum
                                                            ? "left-grid__item-active"
                                                            : ""
                                                        }`}
                                                        onClick={() =>
                                                          handlePageClick(
                                                            item.pageNumber
                                                          )
                                                        }
                                                      >
                                                        <div
                                                          className={`left-grid__item__thumbnail 
                                                                  ${
                                                                    item.pageNumber ===
                                                                    SpecificationLibDetailsState.sectionPageNum
                                                                      ? "left-grid__item__thumbnail-active"
                                                                      : ""
                                                                  }`}
                                                        >
                                                          <LazyLoad
                                                            scrollContainer={
                                                              ".left-grid"
                                                            }
                                                            height={200}
                                                            offset={100}
                                                          >
                                                            <img
                                                              src={item.url}
                                                              className="img-responsive"
                                                            ></img>
                                                          </LazyLoad>
                                                        </div>

                                                        <div className="left-grid__info">
                                                          <div className="left-grid__info__text">
                                                            {`Page number:  ${item.pageNumber}`}
                                                          </div>
                                                          <div className="left-grid__info__action">
                                                            <IconButton
                                                              className="left-grid__info__action__moreIcon"
                                                              onClick={(
                                                                e: any
                                                              ) =>
                                                                handeMoreClick(
                                                                  e,
                                                                  item.pageNumber
                                                                )
                                                              }
                                                            >
                                                              <MoreVertIcon />
                                                            </IconButton>
                                                            {openIndex ===
                                                            item.pageNumber ? (
                                                              <Menu
                                                                id="demo-positioned-menu"
                                                                aria-labelledby="demo-positioned-button"
                                                                anchorEl={
                                                                  anchorEl1
                                                                }
                                                                open={open1}
                                                                onClose={
                                                                  handleClose
                                                                }
                                                                anchorOrigin={{
                                                                  vertical:
                                                                    "top",
                                                                  horizontal:
                                                                    "right",
                                                                }}
                                                                transformOrigin={{
                                                                  vertical:
                                                                    "top",
                                                                  horizontal:
                                                                    "left",
                                                                }}
                                                              >
                                                                <MenuItem
                                                                  onClick={(
                                                                    e: any
                                                                  ) =>
                                                                    handlePopOver(
                                                                      e,
                                                                      item,
                                                                      index
                                                                    )
                                                                  }
                                                                >
                                                                  Start New
                                                                  Section Above
                                                                </MenuItem>
                                                              </Menu>
                                                            ) : null}
                                                          </div>
                                                        </div>
                                                      </div>
                                                    </>
                                                  ) : (
                                                    <div className="left-grid__section-title">
                                                      <Tooltip
                                                        title={`${item.section_number} - ${item.section_name}`}
                                                        aria-label="delete category"
                                                      >
                                                        <label>
                                                          {item.section_name &&
                                                          item.section_name
                                                            .length > 25
                                                            ? `${
                                                                item.section_number
                                                              } - ${item.section_name.slice(
                                                                0,
                                                                25
                                                              )} . . .`
                                                            : `${item.section_number} - ${item.section_name}`}
                                                        </label>
                                                      </Tooltip>
                                                      <IconButton
                                                        className="left-grid__section-title__moreIconBtn"
                                                        onClick={(e: any) =>
                                                          handeSecMoreClick(
                                                            e,
                                                            index
                                                          )
                                                        }
                                                      >
                                                        <MoreVertIcon />
                                                      </IconButton>
                                                      {openSecIndex ===
                                                      index ? (
                                                        // <Box className='review__wrapper__left__pdfDisplay__thumbnail__box'>
                                                        //     <Button onClick={() => handleDelete(index)}>Delete</Button>
                                                        //     <Button onClick={() => handleNotASection(index)}>Not A Section</Button>

                                                        // </Box>
                                                        <Menu
                                                          id="demo-positioned-menu"
                                                          aria-labelledby="demo-positioned-button"
                                                          anchorEl={anchorEl2}
                                                          open={open2}
                                                          onClose={handleClose}
                                                          anchorOrigin={{
                                                            vertical: "top",
                                                            horizontal: "right",
                                                          }}
                                                          transformOrigin={{
                                                            vertical: "top",
                                                            horizontal: "left",
                                                          }}
                                                        >
                                                          <MenuItem
                                                            onClick={() =>
                                                              handleDelete(
                                                                index
                                                              )
                                                            }
                                                          >
                                                            Delete
                                                          </MenuItem>
                                                          <MenuItem
                                                            onClick={() =>
                                                              handleNotASection(
                                                                index
                                                              )
                                                            }
                                                          >
                                                            Not A Section
                                                          </MenuItem>
                                                        </Menu>
                                                      ) : null}
                                                    </div>
                                                  )}
                                                  {/* {provided.placeholder} */}
                                                </div>
                                              )}
                                            </Draggable>
                                          </>
                                        );
                                      }
                                    )}
                                </div>
                              )}
                            </Droppable>
                          </div>
                        </>
                      )}
                    </div>
                  ) : null}

                  <div className="section-review__wrapper__left__pdfDisplay__pdf">
                    <PdfTron specSectionDetails={specSectionDetails} />
                  </div>
                </div>
              </div>
              <div className="section-review__wrapper__sheets">
                <SpecificationSheetsMain publish={handlePublishSpecification} />
              </div>
            </div>
            <Popover
              id={id}
              open={open}
              anchorEl={anchorEl}
              onClose={handleClose}
              anchorOrigin={{
                vertical: "center",
                horizontal: "right",
              }}
              transformOrigin={{
                vertical: "center",
                horizontal: "right",
              }}
            >
              <div className="add-section">
                <InputLabel required={false}>Section Number </InputLabel>
                <TextField
                  type="text"
                  fullWidth
                  autoComplete="search"
                  placeholder="Type Here"
                  variant="outlined"
                  value={newSectionNumber}
                  onChange={(e) => handleSectionNumChange(e)}
                />
                <InputLabel required={false}>Section Name </InputLabel>
                <TextField
                  type="text"
                  fullWidth
                  autoComplete="search"
                  placeholder="Type Here"
                  variant="outlined"
                  value={newSectionName}
                  onChange={(e) => handleSectionNameChange(e)}
                />
                {/* <FormControlLabel
                    className="add-category__checkbox"
                    value={newCategoryStatus}
                    control={<Checkbox color="primary" checked={newCategoryStatus} onChange={(e: any) => handleViewChange(e)}/>}
                    label="Mark as viewed"
                    labelPlacement="end"
                /> */}
                <div className="add-section__action">
                  <div
                    className="add-section__action__cancel"
                    onClick={handleClose}
                  >
                    Cancel
                  </div>
                  <Button
                    type="submit"
                    data-testid={"add-sectionNum"}
                    variant="outlined"
                    className="btn-primary"
                    onClick={addNewSection}
                    size={"small"}
                    disabled={!newSectionName || !newSectionNumber}
                  >
                    Add
                  </Button>
                </div>
              </div>
            </Popover>
          </>
        ) : (
          ""
        )}
      </div>
    </DragDropContext>
  );
}
